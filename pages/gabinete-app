# Streamlit "Gabinete Personal" – versión base sin Google Forms
# Autor: para Regina A. Freyman (Metodologías del Pensamiento Creativo)
# Objetivo: App todo-en-uno para capturar, curar y exhibir gabinetes personales (texto, imágenes y audio),
# evitando el loop de Google Forms/Excel. Usa SQLite para datos y sistema de archivos para media (dev/local).
#
# Nota de despliegue:
# - En local: funciona out‑of‑the‑box.
# - En Streamlit Community Cloud: el sistema de archivos NO es persistente. Para producción
#   migra el almacenamiento de archivos a un bucket (por ej. Supabase Storage, S3, Cloudinary)
#   y cambia MEDIA_BACKEND="local" -> "external" e implementa los dos métodos marcados.
#
# Características:
# - Páginas: Inicio, Crear/Gestionar mi gabinete, Galería, Panel docente (export, analíticas básicas)
# - Formularios en pestañas con validaciones suaves
# - Visualizador de imágenes y reproductor de audio integrados
# - Filtros por grupo/etiquetas/búsqueda
# - Exportación CSV y ZIP para respaldo docente

from __future__ import annotations
import io
import os
from pathlib import Path
from datetime import datetime
from typing import List, Optional

import streamlit as st
from PIL import Image
from sqlmodel import Field, SQLModel, Session, create_engine, select

# ==========================
# Configuración y constantes
# ==========================
APP_TITLE = "Gabinete Personal – Metodologías del Pensamiento Creativo"
APP_DESCRIPTION = (
    "Captura, cuida y comparte tu gabinete personal: arte‑objeto, reflexiones, imágenes y audio. "
    "Todo integrado — sin Google Forms."
)

st.set_page_config(page_title=APP_TITLE, layout="wide")

# Rutas locales (modo desarrollo)
BASE_DIR = Path(__file__).parent
DATA_DIR = BASE_DIR / "data"
DB_PATH = DATA_DIR / "gabinete.db"
UPLOADS_DIR = DATA_DIR / "uploads"
IMG_DIR = UPLOADS_DIR / "images"
AUDIO_DIR = UPLOADS_DIR / "audio"

for p in [DATA_DIR, UPLOADS_DIR, IMG_DIR, AUDIO_DIR]:
    p.mkdir(parents=True, exist_ok=True)

# Backend de media ("local" o "external"). Si usas "external", implementa upload_external() y url_external().
MEDIA_BACKEND = os.getenv("MEDIA_BACKEND", "local")

# Clave sencilla para panel docente (ponla en st.secrets["ADMIN_KEY"] en producción)
ADMIN_KEY = st.secrets.get("ADMIN_KEY", "regina-demo")

# ==================
# Modelo de datos
# ==================
class Entry(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # Perfil
    student_name: str
    email: str
    group: str = Field(default="Grupo A")

    # Obra y metadatos
    artifact_title: str
    artifact_desc: str
    tags: str = Field(default="")  # coma separada

    # Reflexiones (puedes ajustar las preguntas)
    reflection_q1: str = Field(default="")
    reflection_q2: str = Field(default="")
    reflection_q3: str = Field(default="")

    # Media (rutas/URLs, separadas por "||" cuando hay múltiples)
    image_urls: str = Field(default="")
    audio_url: str = Field(default="")
    suno_link: str = Field(default="")


engine = create_engine(f"sqlite:///{DB_PATH}")
SQLModel.metadata.create_all(engine)

# ================
# Utilidades
# ================

def save_image_locally(file) -> str:
    """Guarda imagen en IMG_DIR y retorna ruta relativa (str)."""
    img = Image.open(file).convert("RGB")
    fname = f"img_{datetime.utcnow().strftime('%Y%m%d_%H%M%S_%f')}.jpg"
    out_path = IMG_DIR / fname
    img.save(out_path, format="JPEG", quality=92)
    return str(out_path.relative_to(DATA_DIR))


def save_audio_locally(file) -> str:
    """Guarda audio en AUDIO_DIR y retorna ruta relativa (str)."""
    suffix = Path(file.name).suffix.lower() or ".mp3"
    fname = f"aud_{datetime.utcnow().strftime('%Y%m%d_%H%M%S_%f')}{suffix}"
    out_path = AUDIO_DIR / fname
    with open(out_path, "wb") as f:
        f.write(file.read())
    return str(out_path.relative_to(DATA_DIR))


def upload_external(file, kind: str) -> str:
    """Sube a un servicio externo y retorna URL pública. IMPLEMENTAR si MEDIA_BACKEND=="external".
    kind: "image"|"audio".
    """
    raise NotImplementedError("Configura tu bucket (Supabase/S3/Cloudinary) y esta función.")


def local_to_url(rel_path: str) -> str:
    """Convierte una ruta relativa (dentro de DATA_DIR) a una pseudo-URL servible por Streamlit.
    En Cloud: Streamlit sirve archivos locales con st.download_button o st.audio/st.image si pasamos bytes.
    Para galería, leeremos bytes en tiempo real.
    """
    return rel_path  # mantenemos la ruta relativa dentro de DATA_DIR


def save_media(files: List, kind: str) -> List[str]:
    urls = []
    if not files:
        return urls
    for f in files:
        if MEDIA_BACKEND == "local":
            rel = save_image_locally(f) if kind == "image" else save_audio_locally(f)
            urls.append(local_to_url(rel))
        else:
            urls.append(upload_external(f, kind))
    return urls


def parse_tags(tags_str: str) -> List[str]:
    return [t.strip() for t in tags_str.split(",") if t.strip()]


# ================
# UI – Estilos
# ================
CUSTOM_CSS = """
<style>
/***** Cards *****/
.block-container {padding-top: 1.5rem;}
.card {border-radius: 1.25rem; padding: 1rem 1.25rem; box-shadow: 0 10px 20px rgba(0,0,0,0.08);} 
.card h3 {margin-top: 0.2rem;}
.badge {display:inline-block; padding: .25rem .6rem; border-radius: 999px; background:#eee; margin-right:.35rem; font-size:.8rem}
.meta {opacity:.8; font-size:.9rem}
.grid {display:grid; gap:1rem}
.grid.cols-3 {grid-template-columns: repeat(3, minmax(0, 1fr));}
.grid.cols-4 {grid-template-columns: repeat(4, minmax(0, 1fr));}
@media (max-width: 1100px){ .grid.cols-4 {grid-template-columns: repeat(2, minmax(0,1fr));}}
@media (max-width: 800px){ .grid.cols-3, .grid.cols-4 {grid-template-columns: 1fr;}}
</style>
"""
st.markdown(CUSTOM_CSS, unsafe_allow_html=True)

# ================
# Sidebar & navegación
# ================
st.sidebar.title("Gabinete Personal")
st.sidebar.write(APP_DESCRIPTION)
page = st.sidebar.radio("Ir a", ["Inicio", "Crear mi gabinete", "Galería", "Panel docente"])  # noqa: E501

# =====================
# Página: Inicio
# =====================
if page == "Inicio":
    st.title(APP_TITLE)
    st.write(APP_DESCRIPTION)
    with st.container():
        c1, c2, c3 = st.columns([1.3, 1, 1])
        with c1:
            st.markdown(
                """
                **Flujo**
                1) Completa tu perfil y describe tu arte‑objeto.
                2) Sube imágenes (proceso y obra final).
                3) Responde 3 preguntas de reflexión.
                4) Sube tu audio (o pega tu enlace de Suno) y publica.
                """
            )
        with c2:
            st.markdown("**Tips**\n- Usa etiquetas para agrupar temas.\n- Cuida la iluminación de tus fotos.")
        with c3:
            st.markdown("**Docencia**\n- Revisa el panel para exportar evidencias y ver analíticas.")

# =============================
# Página: Crear mi gabinete
# =============================
if page == "Crear mi gabinete":
    st.title("Crear / Editar mi Gabinete")

    with st.form("gabinete_form", clear_on_submit=False):
        # Perfil
        st.subheader("1) Perfil del estudiante")
        cols = st.columns(3)
        student_name = cols[0].text_input("Nombre completo *")
        email = cols[1].text_input("Email *")
        group = cols[2].selectbox("Grupo", ["Grupo A", "Grupo B", "Grupo C", "Otro"])  # ajusta

        st.markdown("---")
        # Obra
        st.subheader("2) Obra / Arte‑objeto")
        artifact_title = st.text_input("Título de la obra *")
        artifact_desc = st.text_area("Descripción breve *", help="Materiales, intención, metáfora central…")
        tags = st.text_input("Etiquetas (separadas por coma)", placeholder="identidad, memoria, ecofeminismo")

        st.markdown("---")
        # Media – imágenes
        st.subheader("3) Imágenes")
        images = st.file_uploader(
            "Sube 1‑6 imágenes (JPG/PNG)", type=["jpg", "jpeg", "png"], accept_multiple_files=True
        )
        if images and len(images) > 6:
            st.warning("El límite recomendado es 6 imágenes; se guardarán solo las 6 primeras.")
            images = images[:6]

        st.markdown("---")
        # Reflexiones
        st.subheader("4) Reflexiones")
        reflection_q1 = st.text_area("Q1 · ¿Qué representa tu arte‑objeto de ti que no se ve a simple vista?")
        reflection_q2 = st.text_area("Q2 · ¿Qué decisiones materiales/simbólicas fueron clave y por qué?")
        reflection_q3 = st.text_area("Q3 · Si tuvieras que iterar, ¿qué cambiarías y cómo lo validarías?")

        st.markdown("---")
        # Audio / Suno
        st.subheader("5) Audio / Canción")
        audio_file = st.file_uploader("Sube tu audio (MP3/WAV/M4A)", type=["mp3", "wav", "m4a"], accept_multiple_files=False)
        suno_link = st.text_input("o pega el enlace público de tu pista en Suno (opcional)")

        submitted = st.form_submit_button("Publicar mi gabinete")

    if submitted:
        # Validación mínima
        missing = [
            ("Nombre", student_name),
            ("Email", email),
            ("Título", artifact_title),
            ("Descripción", artifact_desc),
        ]
        missing_fields = [m for m, v in missing if not v]
        if missing_fields:
            st.error("Faltan campos obligatorios: " + ", ".join(missing_fields))
        else:
            # Guardar media primero
            img_urls = save_media(images, kind="image") if images else []
            aud_urls = save_media([audio_file], kind="audio") if audio_file else []

            with Session(engine) as session:
                entry = Entry(
                    student_name=student_name.strip(),
                    email=email.strip(),
                    group=group,
                    artifact_title=artifact_title.strip(),
                    artifact_desc=artifact_desc.strip(),
                    tags=tags.strip(),
                    reflection_q1=reflection_q1.strip(),
                    reflection_q2=reflection_q2.strip(),
                    reflection_q3=reflection_q3.strip(),
                    image_urls="||".join(img_urls),
                    audio_url=aud_urls[0] if aud_urls else "",
                    suno_link=suno_link.strip(),
                )
                session.add(entry)
                session.commit()
            st.success("¡Tu gabinete ha sido publicado!")

# =====================
# Página: Galería
# =====================
if page == "Galería":
    st.title("Galería de Gabinetes")

    # Controles de filtro/búsqueda
    colf = st.columns([1, 1, 2])
    group_f = colf[0].selectbox("Grupo", ["Todos", "Grupo A", "Grupo B", "Grupo C", "Otro"])
    search = colf[1].text_input("Buscar", placeholder="título, nombre, etiqueta…")
    tag_f = colf[2].text_input("Filtrar por etiqueta específica (exacta)")

    with Session(engine) as session:
        stmt = select(Entry).order_by(Entry.created_at.desc())
        entries = list(session.exec(stmt))

    def match(e: Entry) -> bool:
        if group_f != "Todos" and e.group != group_f:
            return False
        if search:
            s = search.lower()
            blob = " ".join([
                e.student_name, e.email, e.group, e.artifact_title, e.artifact_desc, e.tags,
                e.reflection_q1, e.reflection_q2, e.reflection_q3,
            ]).lower()
            if s not in blob:
                return False
        if tag_f:
            tags = parse_tags(e.tags)
            if tag_f.strip() not in tags:
                return False
        return True

    filtered = [e for e in entries if match(e)]
    st.caption(f"Mostrando {len(filtered)} de {len(entries)} gabinetes")

    # Render cards
    st.markdown('<div class="grid cols-3">', unsafe_allow_html=True)
    for e in filtered:
        # Card container
        st.markdown('<div class="card">', unsafe_allow_html=True)
        st.markdown(f"<h3>{e.artifact_title}</h3>", unsafe_allow_html=True)
        st.markdown(f"<div class='meta'>Por {e.student_name} — {e.group}</div>", unsafe_allow_html=True)

        # Imágenes (mostrar 1ra y toggle para ver más)
        img_urls = [u for u in e.image_urls.split("||") if u]
        if img_urls:
            first = DATA_DIR / img_urls[0]
            if first.exists():
                st.image(str(first), use_container_width=True)
            if len(img_urls) > 1:
                with st.expander(f"Ver {len(img_urls)-1} imagen(es) adicional(es)"):
                    for u in img_urls[1:]:
                        p = DATA_DIR / u
                        if p.exists():
                            st.image(str(p), use_container_width=True)

        st.write(e.artifact_desc)

        # Etiquetas
        tags = parse_tags(e.tags)
        if tags:
            st.markdown(" ".join([f"<span class='badge'>{t}</span>" for t in tags]), unsafe_allow_html=True)

        # Audio/Suno
        if e.audio_url:
            ap = DATA_DIR / e.audio_url
            if ap.exists():
                with open(ap, "rb") as f:
                    st.audio(f.read())
        if e.suno_link:
            st.link_button("Escuchar en Suno", e.suno_link)

        with st.expander("Reflexiones"):
            st.markdown(f"**Q1** {e.reflection_q1}")
            st.markdown(f"**Q2** {e.reflection_q2}")
            st.markdown(f"**Q3** {e.reflection_q3}")

        st.markdown('</div>', unsafe_allow_html=True)  # end card
    st.markdown('</div>', unsafe_allow_html=True)  # end grid

# =====================
# Página: Panel docente
# =====================
if page == "Panel docente":
    st.title("Panel docente")

    key = st.text_input("Clave docente", type="password")
    if key != ADMIN_KEY:
        st.info("Introduce la clave docente para ver y exportar datos.")
        st.stop()

    with Session(engine) as session:
        entries = list(session.exec(select(Entry).order_by(Entry.created_at.desc())))

    st.subheader("Resumen")
    cols = st.columns(4)
    cols[0].metric("Total gabinetes", len(entries))
    cols[1].metric("Con audio", sum(1 for e in entries if e.audio_url or e.suno_link))
    cols[2].metric("Con >2 imágenes", sum(1 for e in entries if len([u for u in e.image_urls.split('||') if u]) > 2))
    groups = {}
    for e in entries:
        groups[e.group] = groups.get(e.group, 0) + 1
    cols[3].metric("Grupos", len(groups))

    st.markdown("---")
    st.subheader("Exportar datos")

    # Export CSV (metadatos)
    import csv
    import pandas as pd

    csv_buf = io.StringIO()
    writer = csv.writer(csv_buf)
    writer.writerow([
        "id","created_at","student_name","email","group","artifact_title","artifact_desc",
        "tags","reflection_q1","reflection_q2","reflection_q3","image_urls","audio_url","suno_link",
    ])
    for e in entries:
        writer.writerow([
            e.id, e.created_at.isoformat(), e.student_name, e.email, e.group, e.artifact_title, e.artifact_desc,
            e.tags, e.reflection_q1, e.reflection_q2, e.reflection_q3, e.image_urls, e.audio_url, e.suno_link,
        ])
    csv_bytes = csv_buf.getvalue().encode("utf-8")
    st.download_button("Descargar CSV", data=csv_bytes, file_name="gabinetes.csv", mime="text/csv")

    # Export ZIP (media + CSV)
    from zipfile import ZipFile, ZIP_DEFLATED

    zip_buf = io.BytesIO()
    with ZipFile(zip_buf, "w", ZIP_DEFLATED) as zf:
        # CSV
        zf.writestr("gabinetes.csv", csv_bytes)
        # Media
        for e in entries:
            for u in [u for u in e.image_urls.split("||") if u]:
                p = DATA_DIR / u
                if p.exists():
                    zf.write(p, arcname=str(Path("media") / u))
            if e.audio_url:
                ap = DATA_DIR / e.audio_url
                if ap.exists():
                    zf.write(ap, arcname=str(Path("media") / e.audio_url))
    st.download_button("Descargar ZIP (CSV + media)", data=zip_buf.getvalue(), file_name="gabinetes_media.zip", mime="application/zip")

    st.markdown("---")
    st.subheader("Vista de tabla")

    # Vista rápida en tabla
    import pandas as pd
    df = pd.DataFrame([
        {
            "ID": e.id,
            "Creado": e.created_at.strftime("%Y-%m-%d %H:%M"),
            "Nombre": e.student_name,
            "Email": e.email,
            "Grupo": e.group,
            "Título": e.artifact_title,
            "Etiquetas": e.tags,
            "#Imágenes": len([u for u in e.image_urls.split("||") if u]),
            "Audio?": bool(e.audio_url or e.suno_link),
        }
        for e in entries
    ])
    st.dataframe(df, use_container_width=True)


# =============
# Pie de página
# =============
st.markdown("---")
st.caption("Hecho con ❤️ por el Gabinete del Asombro · Streamlit + SQLite (versión base)")
